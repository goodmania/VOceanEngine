#version 450

struct Ocean
{
	vec2 H_y;
	vec2 H_x;
	vec2 H_z;
	vec2 Dx;
	vec2 Dz;
};

layout(std430, binding = 0) buffer H0Buffer
{
	Ocean H0Buffers[ ];
};

layout(std430, binding = 1) buffer HtBuffer 
{
	Ocean HtBuffers[ ];
};

layout(std430, binding = 2) buffer Ht_dmyBuffer 
{
	Ocean Ht_dmyBuffers[ ];
};

layout (std140, binding = 3) uniform UBO 
{
	float deltaT;
	float lambda;
	highp uint meshSize;
	highp uint OceanSizeLx;
	highp uint OceanSizeLz;
} ubo;

const float dx = 1.0f * ubo.OceanSizeLx / ubo.meshSize;
const float dz = 1.0f * ubo.OceanSizeLx / ubo.meshSize;

layout (local_size_x = 256) in;

void main()
{
	uint N = ubo.meshSize;
	uvec3 id = gl_GlobalInvocationID;
    uint x0 = (id.x - 1 + N) % N;
    uint x1 = (id.x + 1) % N;
    uint y0 = (id.y - 1 + N) % N;
    uint y1 = (id.y + 1) % N;

    float subx = HtBuffers[id.x + id.y * N].H_x.x;
    float subz = HtBuffers[id.x + id.y * N].H_z.x;

    //displaceXZÇæÇØíËã`ì_Ç™à⁄ìÆÇ∑ÇÈÇ±Ç∆ÇçlÇ¶Ç±Ç±Ç≈åXÇ´ÇÇ≥ÇÁÇ…Ç¢Ç∂ÇÈ
    subx *= 2.0 * dx / ((HtBuffers[x1 + id.y * N].Dx.y - HtBuffers[x0 + id.y * N].Dx.y) * ubo.lambda + 2.0 * dx);
    subz *= 2.0 * dz / ((HtBuffers[id.x + y1 * N].Dz.y - HtBuffers[id.x + y0 * N].Dz.y) * ubo.lambda + 2.0 * dz);
    vec3 Normarized = normalize(vec3(-subx, 1.0, -subz));
    vec4 out4 = (Normarized, 1.0f)

    tex[id] = out4;
}