#version 450
#define PI 3.14159265358979323846264338327950288

struct Ocean
{
	vec2 H_y;
	vec2 H_x;
	vec2 H_z;
	vec2 Dx;
	vec2 Dz;
};

layout(std430, binding = 0) buffer H0Buffer
{
	Ocean H0Buffers[ ];
};

layout(std430, binding = 1) buffer HtBuffer 
{
	Ocean HtBuffers[ ];
};

layout(std430, binding = 2) buffer Ht_dmyBuffer 
{
	Ocean Ht_dmyBuffers[ ];
};

layout (std140, binding = 3) uniform UBO 
{
	float deltaT;
	highp uint meshSize;
	highp uint OceanSizeLx;
	highp uint OceanSizeLz;
} ubo;

layout (local_size_x = 256) in;

vec2 conjugate(vec2 arg)
{
    vec2 f2;
    f2.x = arg.x;
    f2.y = -arg.y;
    return f2;
}

vec2 MultiplyComplex(vec2 a, vec2 b)
{
	return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 AddComplex(vec2 a, vec2 b)
{
	return vec2(a.x + b.x , a.y + b.y);
}

vec2 ComplexExp(float a)
{
    return vec2(cos(a), sin(a));
}

void main()
{
	uvec3 id = gl_GlobalInvocationID; 

	uint in_index = id.y * ubo.meshSize + id.x;
    uint in_mindex = (ubo.meshSize - id.y) % ubo.meshSize * ubo.meshSize + (ubo.meshSize - id.x) % ubo.meshSize; // mirrored
    uint out_index = id.y * ubo.meshSize + id.x;

	vec2 k;
	k.x = (-ubo.meshSize / 2.0f + id.x) * (2.0f * PI / ubo.OceanSizeLx);
	k.y = (-ubo.meshSize / 2.0f + id.y) * (2.0f * PI / ubo.OceanSizeLz);

	float k_len = sqrt(k.x * k.x + k.y * k.y);
    float w = sqrt(9.81f * k_len);

	vec2 h0_k  = H0Buffers[in_index].H_y;
	vec2 h0_mk = H0Buffers[in_mindex].H_y;

	vec2 htval = AddComplex(
			MultiplyComplex(h0_k, ComplexExp(w * ubo.deltaT)),				
			MultiplyComplex(conjugate(h0_mk), ComplexExp(-w * ubo.deltaT)));
	
	HtBuffers[out_index].H_y = htval;

	vec2 htival; // i*htval
	htival.x = -htval.y;
	htival.y = htval.x;
	HtBuffers[out_index].H_x = htival * k.x;
	HtBuffers[out_index].H_z = htival * k.y;

	if (k_len != 0.0) 
	{
		k.x /= k_len;
		k.y /= k_len;
	}
	
	HtBuffers[out_index].Dx = -htival * k.x;
	HtBuffers[out_index].Dz = -htival * k.y;
}
