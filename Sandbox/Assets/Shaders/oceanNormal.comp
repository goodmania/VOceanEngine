#version 450

layout(std430, set = 0, binding = 0) buffer H0Buffer
{
	vec2 H0Buffers[ ];
};

layout(std430, set = 0, binding = 1) buffer HtBuffer 
{
	vec2 HtBuffers[ ];
};

layout(std430, set = 0, binding = 2) buffer Ht_dmyBuffer 
{
	vec2 Ht_dmyBuffers[ ];
};

layout (std140, set = 0, binding = 3) uniform UBO 
{
	float deltaT;
	float lambda;
	uint meshSize;
	highp uint OceanSizeLx;
	highp uint OceanSizeLz;
} ubo;

layout(std430, set = 0, binding = 4) buffer OceanNormalBuffer
{
	vec4 OceanNormalBuffers[ ];
};

layout (local_size_x = 256) in;

void main()
{
	float dx = 1.0f * ubo.OceanSizeLx / ubo.meshSize;
	float dz = 1.0f * ubo.OceanSizeLx / ubo.meshSize;

	uint N = ubo.meshSize;
	uint offset = N * N; // 0 ht_y, 1 ht_x, 2 ht_z, 3 dx 4 dz
	uvec3 id = gl_GlobalInvocationID;
    uint x0 = (id.x - 1 + N) % N;
    uint x1 = (id.x + 1) % N;
    uint y0 = (id.y - 1 + N) % N;
    uint y1 = (id.y + 1) % N;

    float subx = HtBuffers[id.x + id.y * N + 1 * offset].y;
    float subz = HtBuffers[id.x + id.y * N + 2 * offset].y;

    //displaceXZÇæÇØíËã`ì_Ç™à⁄ìÆÇ∑ÇÈÇ±Ç∆ÇçlÇ¶Ç±Ç±Ç≈åXÇ´ÇÇ≥ÇÁÇ…Ç¢Ç∂ÇÈ
    subx *= 2.0 * dx / ((HtBuffers[x1 + id.y * N + 3 * offset].y - HtBuffers[x0 + id.y * N + 3 * offset].y) * ubo.lambda + 2.0 * dx);
    subz *= 2.0 * dz / ((HtBuffers[id.x + y1 * N + 4 * offset].y - HtBuffers[id.x + y0 * N + 4 * offset].y) * ubo.lambda + 2.0 * dz);
    vec3 Normarized = normalize(vec3(-subx, 1.0f, -subz));

    OceanNormalBuffers[id.y * N + id.x] = vec4(Normarized, 1.0f);
}