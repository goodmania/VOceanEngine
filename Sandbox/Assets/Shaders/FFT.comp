#version 450
#define PI 3.14159265358979323846264338327950288

#define M (8)
#define N (1<<M)

layout(std430, binding = 0) buffer H0Buffer
{
	vec2 H0Buffers[ ];
};

layout(std430, binding = 1) buffer HtBuffer 
{
	vec2 HtBuffers[ ];
};

layout(std430, binding = 2) buffer Ht_dmyBuffer 
{
	vec2 Ht_dmyBuffers[ ];
};

layout (std140, binding = 3) uniform UBO 
{
	float deltaT;
	highp uint meshSize;
	highp uint OceanSizeLx;
	highp uint OceanSizeLz;
} ubo;

// GLSL�ł�HLSL�� numthreads �̑���� layout �� local_size_[xyz] ���w�肵�܂��B
layout (local_size_x = N/2) in;

shared vec2 block[N];

void main()
{
    uvec3 id = gl_GlobalInvocationID;
    uvec3 grid = gl_WorkGroupID;
    uint gi = gl_LocalInvocationIndex;
    block[gi * 2] = HtBuffers[grid.x * N + gi * 2];
    block[gi * 2 + 1] = HtBuffers[grid.x * N + gi * 2 + 1];

    for (int loopidx = 0; loopidx < M; loopidx++)
    {
        int dleng = 1 << (M - loopidx - 1);
        uint t = gi % dleng;
        uint t0 = (gi / dleng) * dleng * 2 + t;
        uint t1 = t0 + dleng;

        groupMemoryBarrier();
        //memoryBarrier();
        
        float r1 = block[t1].x;
        float i1 = block[t1].y;
        float r0 = block[t0].x - r1;
        float i0 = block[t0].y - i1;
        float rad = PI * ubo.deltaT / dleng;    //inv�Ȃ̂�-���������Ă���
        float fsin = sin(rad);
        float fcos = cos(rad);

        block[t0].x += r1;
        block[t0].y += i1;
        block[t1].x = r0 * fcos - i0 * fsin;
        block[t1].y = r0 * fsin + i0 * fcos;
    }

    groupMemoryBarrier();
    //memoryBarrier();

    vec2 reim0 = block[bitfieldReverse(gi * 2) >> (32 - M)];    //32��uint=32bit��32
    vec2 reim1 = block[bitfieldReverse(gi * 2 + 1) >> (32 - M)];
    reim1 = -reim1;

    Ht_dmyBuffers[(gi * 2 + N / 2) % N * N + grid.x] = reim0;
    Ht_dmyBuffers[(gi * 2 + 1 + N / 2) % N * N + grid.x] = reim1;
}