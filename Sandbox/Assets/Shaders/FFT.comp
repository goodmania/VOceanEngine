#version 450
#define PI 3.14159265358979323846264338327950288

#define M (8)
#define N (1<<M)

struct Ocean
{
	vec2 H_y;
	vec2 H_x;
	vec2 H_z;
    vec2 Dx;
	vec2 Dz;
};

layout(std430, binding = 0) buffer H0Buffer
{
	Ocean H0Buffers[ ];
};

layout(std430, binding = 1) buffer HtBuffer 
{
	Ocean HtBuffers[ ];
};

layout(std430, binding = 2) buffer Ht_dmyBuffer
{
	Ocean Ht_dmyBuffers[ ];
};

layout (std140, binding = 3) uniform UBO 
{
	float deltaT;
	highp uint meshSize;
	highp uint OceanSizeLx;
	highp uint OceanSizeLz;
} ubo;

layout (local_size_x = N/2) in;

shared Ocean block[N];

void main()
{
    uvec3 id = gl_GlobalInvocationID;
    uvec3 grid = gl_WorkGroupID;
    uint gi = gl_LocalInvocationIndex;

    block[gi * 2] = HtBuffers[grid.x * N + gi * 2];
    block[gi * 2 + 1] = HtBuffers[grid.x * N + gi * 2 + 1];

    for (int loopidx = 0; loopidx < M; loopidx++)
    {
        int dleng = 1 << (M - loopidx - 1);
        uint t = gi % dleng;
        uint t0 = (gi / dleng) * dleng * 2 + t;
        uint t1 = t0 + dleng;

        float rad = PI * t / dleng;    
        float fsin = sin(rad);
        float fcos = cos(rad);

        groupMemoryBarrier();
        barrier();
        
        // y
        float r1_y = block[t1].H_y.x;
        float i1_y = block[t1].H_y.y;
        float r0_y = block[t0].H_y.x - r1_y;
        float i0_y = block[t0].H_y.y - i1_y;

        block[t0].H_y.x += r1_y;
        block[t0].H_y.y += i1_y;
        block[t1].H_y.x = r0_y * fcos - i0_y * fsin;
        block[t1].H_y.y = r0_y * fsin + i0_y * fcos;

        groupMemoryBarrier();
        barrier();

        // Dx
        float r1_x = block[t1].Dx.x;
        float i1_x = block[t1].Dx.y;
        float r0_x = block[t0].Dx.x - r1_x;
        float i0_x = block[t0].Dx.y - i1_x;

        block[t0].Dx.x += r1_x;
        block[t0].Dx.y += i1_x;
        block[t1].Dx.x = r0_x * fcos - i0_x * fsin;
        block[t1].Dx.y = r0_x * fsin + i0_x * fcos;

        groupMemoryBarrier();
        barrier();

        // Dz
        float r1_z = block[t1].Dz.x;
        float i1_z = block[t1].Dz.y;
        float r0_z = block[t0].Dz.x - r1_z;
        float i0_z = block[t0].Dz.y - i1_z;

        block[t0].Dz.x += r1_z;
        block[t0].Dz.y += i1_z;
        block[t1].Dz.x = r0_z * fcos - i0_z * fsin;
        block[t1].Dz.y = r0_z * fsin + i0_z * fcos;
    }

    groupMemoryBarrier();
    barrier();

    // y
    vec2 reim0_y = block[bitfieldReverse(gi * 2) >> (32 - M)].H_y;    
    vec2 reim1_y = block[bitfieldReverse(gi * 2 + 1) >> (32 - M)].H_y;
    reim1_y = -reim1_y;

    // Dx
    vec2 reim0_x = block[bitfieldReverse(gi * 2) >> (32 - M)].Dx;    
    vec2 reim1_x = block[bitfieldReverse(gi * 2 + 1) >> (32 - M)].Dx;
    reim1_x = -reim1_x;

    // Dz
    vec2 reim0_z = block[bitfieldReverse(gi * 2) >> (32 - M)].Dz;    
    vec2 reim1_z = block[bitfieldReverse(gi * 2 + 1) >> (32 - M)].Dz;
    reim1_z = -reim1_z;

    Ht_dmyBuffers[(gi * 2 + N / 2) % N * N + grid.x].H_y = reim0_y;
    Ht_dmyBuffers[(gi * 2 + 1 + N / 2) % N * N + grid.x].H_y = reim1_y;

    Ht_dmyBuffers[(gi * 2 + N / 2) % N * N + grid.x].Dx = reim0_x;
    Ht_dmyBuffers[(gi * 2 + 1 + N / 2) % N * N + grid.x].Dx = reim1_x;

    Ht_dmyBuffers[(gi * 2 + N / 2) % N * N + grid.x].Dz = reim0_z;
    Ht_dmyBuffers[(gi * 2 + 1 + N / 2) % N * N + grid.x].Dz = reim1_z;
}